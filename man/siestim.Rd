% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/siestim.R
\name{siestim}
\alias{siestim}
\title{Serial Interval Estimation}
\usage{
siestim(x, init, lower, upper, control = list(ncore = 2))
}
\arguments{
\item{x}{vector or a list of vectors of the observed symptom onset interval between a pair
of infector-infectee. See 'Details'.}

\item{init}{initial values of the estimates (\code{mu}, \code{sigma}, \code{pi}, \code{w}), where \code{pi}, \code{sigma} > 0,
0 < \code{pi} <= 1 and
0 <= \code{w} <= 1. See "Details".}

\item{lower, upper}{bounds on the estimates, cannot be \code{NA} or \code{NULL}. By order,
it is \code{mu}, \code{sigma}, \code{pi}, \code{w}.}

\item{control}{a list of control parameters. See "Details".}
}
\value{
The function returns the following values: \cr
\itemize{
  \item \code{par}: point estimation of each parameter.
  \item \code{se}: standard error of each estimate.
  \item \code{logll}: log-likelihood value evaluated at \code{par}.
  \item \code{msg}: convergence message of the optimization.
}
}
\description{
An optimization method (MLE/MAP) to estimate serial interval distribution.
}
\details{
If the transmission trees are non-unique, \code{x} must be
expressed as a list, in which each element represents the observed serial interval data
per one transmission tree. \cr

If \code{x} is a list of length greater than one, the estimation will be performed by parallel.
By default, only 2 cores will be used.

\code{init} is a numeric vector (cannot be \code{NA} or \code{NULL}) which
(by order) depicts the initial value of \code{mu}, \code{sigma}, \code{pi}, \code{w}.
\itemize{
   \item \code{mu}, \code{sigma} are mean and standard deviation of the Gamma distributed serial interval,
   \item \code{pi} is the success probability to sample the secondary cases in non-coprimary transmissions (see \code{?cgg}),
   \item \code{w} is the probability of non-coprimary transmissions in the data.
}
\cr
\code{control} argument is a list that can supply any of the following components:
\itemize{
   \item \code{prior.mu}: a function if the prior distribution of \code{mu} is provided.
   \item \code{prior.sigma}: a function if the prior distribution of \code{sigma} is provided.
   \item \code{prior.pi}: a function if the prior distribution of \code{pi} is provided.
   \item \code{prior.w}: a function if the prior distribution of \code{w} is provided.
   \item \code{ncore}: number of physical CPUs/cores to be used during the computation.
   Only when \code{length(x)} > 1. By default \code{ncore} = 2.
} \cr
The observed serial intervals are assumed coming from two transmission types: coprimary and
non-coprimary transmissions. The density is a mixture of the two transmission distributions,
which is given as follows
\deqn{f(t) = w*g(t|mu,sigma,pi) + (1-w)*h(t|mu,sigma),  t \ge 0,}
where \eqn{g(t), h(t)} are the densities of Compound Geometric Gamma (CGG) distribution
and Folded Gamma Difference (FGD) distribution, respectively. The density above shares the
same parameters with the true serial interval distribution, i.e. the mean \code{mu} and the
standard deviation \code{sigma}. \cr\cr
If the transmission trees are not unique (i.e. \code{x} is a list of length > 1), the estimations
are computed by taking average over all estimates from the transmission trees. \cr
}
\examples{
#simulate data
set.seed(1)
n <- 500
par <- c(5, 2, .4, .7)
m <- rbinom(1, n, par[4])
data <- lapply(1:5, function (i) c(rcgg(m,par[1],par[2],par[3]), rfgd(n-m,par[1],par[2])))

#estimate the parameter
est <- siestim(data, c(7, 3, .5, .5), rep(0, 4), c(10, 5, 1, 1))
est
plot(est)

}
